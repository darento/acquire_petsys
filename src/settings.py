import os
import re
import subprocess
import pandas as pd
import shutil
from typing import Dict, Any


class BiasSettings:
    def __init__(self, dictionary: Dict[str, Any], bias_ref_params: list):
        self.dictionary = dictionary
        self.bias_ref_params = set(bias_ref_params)
        self.bias_settings_path = dictionary["config_directory"]
        self.bias_settings_file_name = "bias_settings.tsv"
        self.bias_df = pd.read_csv(
            self.bias_settings_path + self.bias_settings_file_name, sep="\t"
        )

    def set_fixedvoltages(self) -> None:
        self.bias_df["Pre-breakdown"] = self.dictionary["prebreak_voltage"]
        self.bias_df["Breakdown"] = self.dictionary["break_voltage"]
        if self.bias_ref_params:
            ref_det_volt = self.dictionary["ref_det_volt"]
            for slot, channel in self.bias_ref_params:
                self.bias_df.loc[
                    (self.bias_df["slotID"] == slot)
                    & (self.bias_df["channelID"] == channel),
                    "Pre-breakdown",
                ] = ref_det_volt[0]
                self.bias_df.loc[
                    (self.bias_df["slotID"] == slot)
                    & (self.bias_df["channelID"] == channel),
                    "Breakdown",
                ] = ref_det_volt[1]
                self.bias_df.loc[
                    (self.bias_df["slotID"] == slot)
                    & (self.bias_df["channelID"] == channel),
                    "Overvoltage",
                ] = ref_det_volt[2]

    def set_overvoltage(self, voltage: float) -> None:
        self.bias_df.loc[
            ~self.bias_df[["slotID", "channelID"]]
            .apply(tuple, axis=1)
            .isin(self.bias_ref_params),
            "Overvoltage",
        ] = voltage

    def write_bias_settings(self) -> None:
        new_bias_settings_path = self.dictionary["config_directory"]
        new_bias_settings_file_name = "bias_settings.tsv"
        full_path = new_bias_settings_path + new_bias_settings_file_name

        # Create a backup of the original file
        shutil.copy(full_path, full_path.replace(".tsv", "_backup.tsv"))

        # Write the new bias settings
        self.bias_df.to_csv(full_path, index=False, sep="\t")


class DiscSettings:
    def __init__(self, dictionary: Dict[str, Any], disc_ref_params: list):
        self.dictionary = dictionary
        self.disc_ref_params = set(disc_ref_params)
        self.disc_settings_path = dictionary["config_directory"]
        self.disc_settings_file_name = "disc_settings.tsv"
        self.disc_df = pd.read_csv(
            self.disc_settings_path + self.disc_settings_file_name, sep="\t"
        )

    def set_fixedthresholds(self) -> None:
        self.disc_df["vth_t1"] = self.dictionary["vth_t1"][0]
        self.disc_df["vth_t2"] = self.dictionary["vth_t2"][0]
        self.disc_df["vth_e"] = self.dictionary["vth_e"][0]
        if self.disc_ref_params:
            ref_det_th = self.dictionary["ref_det_ths"]
            for chipID in self.disc_ref_params:
                self.disc_df.loc[(self.disc_df["chipID"] == chipID), "vth_t1"] = (
                    ref_det_th[0]
                )
                self.disc_df.loc[(self.disc_df["chipID"] == chipID), "vth_t2"] = (
                    ref_det_th[1]
                )
                self.disc_df.loc[(self.disc_df["chipID"] == chipID), "vth_e"] = (
                    ref_det_th[2]
                )

    def set_threshold(self, threshold: int, key: str) -> None:
        # self.disc_df.loc[~self.disc_df[['chipID']].isin(self.disc_ref_params).any(1), key] = threshold
        self.disc_df.loc[~self.disc_df["chipID"].isin(self.disc_ref_params), key] = (
            threshold
        )

    def write_disc_settings(self) -> None:
        new_disc_settings_path = self.dictionary["config_directory"]
        new_disc_settings_file_name = "disc_settings.tsv"
        full_path = new_disc_settings_path + new_disc_settings_file_name

        # Create a backup of the original file
        shutil.copy(full_path, full_path.replace(".tsv", "_backup.tsv"))

        # Write the new discriminator settings
        self.disc_df.to_csv(full_path, index=False, sep="\t")


class Commands:
    def __init__(self, dictionary: Dict[str, Any]):
        self.dictionary = dictionary

    def acquire_data(self, full_out_name: str) -> None:
        if not os.path.isdir(self.dictionary["out_directory"]):
            os.makedirs(self.dictionary["out_directory"])
        hw_trigger = "--enable-hw-trigger" if self.dictionary["hw_trigger"] else ""
        command = (
            f"./acquire_sipm_data --config {self.dictionary['config_directory']}config.ini "
            f"--mode {self.dictionary['mode']} --time {self.dictionary['time']} "
            f"-o {self.dictionary['out_directory']}{full_out_name} {hw_trigger}"
        )
        # Regex to capture "all events were lost for 1 (  0.0%) frames"
        pattern = re.compile(
            r"all events were lost for\s+(\d+)\s*\(\s*([\d\.]+)%\)\s*frames",
            re.IGNORECASE,
        )

        lost_info = None
        process = subprocess.Popen(
            command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
        )
        try:
            for line in process.stdout:
                print(line, end="")  # Print the output line by line
                match = pattern.search(line)
                if match:
                    lost_info = {
                        "lost_frames": int(match.group(1)),
                        "lost_percent": float(match.group(2)),
                        "matched_line": line.strip(),
                    }
        finally:
            process.stdout.close()
            process.wait()
        return lost_info

        # print(command + "\n")
        # os.system(command)

    def process_data(self, full_out_name: str, split_time: float = -1) -> None:
        data_type_mapping = {
            "coincidence": ("_coinc", "./convert_raw_to_coincidence"),
            "single": ("_single", "./convert_raw_to_single"),
            "group": ("_group", "./convert_raw_to_group"),
        }
        data_format_compact = (
            ["--writeTextCompact", "Compact"]
            if self.dictionary["data_compact"]
            else ["", ""]
        )
        data_format_mapping = {
            "txt": f"{data_format_compact[0]}",
            "binary": f"--writeBinary{data_format_compact[1]}",
            "root": "--writeRoot",
        }
        sufix, process_command = data_type_mapping[self.dictionary["data_type"]]
        output_format = data_format_mapping[self.dictionary["data_format"]]
        process_out_name = (
            full_out_name + sufix + "Compact"
            if self.dictionary["data_compact"]
            else full_out_name + sufix
        )
        split_string = f"--splitTime {split_time}" if split_time > 0 else ""
        command = (
            f"{process_command} --config {self.dictionary['config_directory']}config.ini "
            f"-i {full_out_name} "
            f"-o {process_out_name} "
            f"--writeMultipleHits {self.dictionary['hits']} {output_format} {split_string} "
        )

        # print(command + "\n")
        os.system(command)
